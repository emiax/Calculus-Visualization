<!doctype html>
<html lang="en">
	<head>
		<title>three.js webgl - geometries</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
			#console {
				color: #9f8;
			}
		</style>
	</head>
	<body>
		<script type="text/javascript">
		    function pln(a) {
		        console.log(a);
		    }

		</script>
		<script src="../build/Three.js"></script>
		<script src="../src/calculus/calc.js"></script>

		<script src="../src/calculus/expressionTree.js"></script>
		<script src="../src/calculus/nodeVisitor.js"></script>
		<script src="../src/calculus/evaluator.js"></script>
		<script src="../src/calculus/simplifier.js"></script>
		<script src="../src/calculus/differentiator.js"></script>
		<script src="../src/calculus/parser.js"></script>
		<script src="../src/calculus/tangent.js"></script>
		<script src="../src/calculus/scheduler.js"></script>


		<script src="../src/calculus/FunctionSurfaceGeometry.js"></script>
		<script src="../src/calculus/ParametricSurfaceGeometry.js"></script>
		<script src="../src/calculus/FunctionCurveGeometry.js"></script>
		<script src="../src/calculus/ParametricCurveGeometry.js"></script>
		


		<script src="js/Detector.js"></script>
		<script src="js/Stats.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, objectsBranch, renderer;
			
			var texture_placeholder,
			isUserInteracting = false,
			wasUserInteracting = false,
			spinZ = 0, spinX = 0, stepZ = 0, stepX = 0, curX = 0, curY = 0,
			recX = [0,0,0,0,0,0,0,0,0,0,0], recY = [0,0,0,0,0,0,0,0,0,0,0], rec = 0,
			onMouseDownMouseX = 0, onMouseDownMouseY = 0,
			lon = 0, lastLon = 0, onMouseDownLon = 0,
			lat = 0, lastLat = 0, onMouseDownLat = 0,
			phi = 0, theta = 0,
			target = new THREE.Vector3();
			origin = new THREE.Vector3(0,0,0);

			init();
			//animate();
			CALC.scheduler.tick();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();

				camera = new THREE.ScreenCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.y = 10;
				camera.position.z = 2;
				camera.lookAt(origin);
				scene.add(camera);

				var light, object, materials;

				scene.add( new THREE.AmbientLight( 0x404040 ) );

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 1000, 400 );
				scene.add( light );

				/*materials = [
					new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: THREE.ImageUtils.loadTexture( 'textures/ash_uvgrid01.jpg' ) } ),
					new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true, transparent: true, opacity: 0.1 } )
				];*/

				surface1 = new THREE.MeshBasicMaterial( { color: 0xbbbbff, wireframe: false, transparent: true, opacity: 0.5 } );
				wireframe1 = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true, transparent: true, opacity: 0.1 } );
				wireframe2 = new THREE.MeshBasicMaterial( { color: 0x557799, wireframe: true, transparent: true, opacity: 0.6 } );
				
				materials = [
					//new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: THREE.ImageUtils.loadTexture( 'textures/ash_uvgrid01.jpg' ) } ),
					surface1,
					wireframe1

				];

				
				objectsBranch = new THREE.Branch();
				objectsBranch.position.set( 0, 0, 0 );
				scene.add(objectsBranch);
				
				//torus test
				var xExpr = CALC.parse('cos(2*s)');
				var yExpr = CALC.parse('sin(2*s)');
				var zExpr = CALC.parse('sin((0-3)*s)');
				var pcg = new CALC.ParametricCurveGeometry(xExpr, yExpr, zExpr, {s:[0, 2*Math.PI]}, null, 0.05);
				object = new THREE.Line(pcg, wireframe2);
				objectsBranch.add(object);

				//var expr = CALC.parse('0');
				var expr = CALC.parse('sin(x)*cos(y/2)');
				var dfdx = expr.tangentialPlane(-1.2, -2.8);
				//console.log(dfdx);

				//var expr = CALC.parse('0');
				var pz = CALC.parse('cos(s+t/2) + 2.5');
				var py = CALC.parse('sin(s+t/3)');
				var px = CALC.parse('t*2');
				
				//console.log(dfdx);
				var fn = new CALC.ParametricSurfaceGeometry(px, py, pz, {s: [0, 3*Math.PI/2], t: [-2, 2]}, null, 0.2);
				object = new THREE.Mesh(fn, wireframe2);
				object.doubleSided = true;
				object.position.set( 0, 0, 0 );
				//objectsBranch.add(object);

				var fn = new CALC.FunctionSurfaceGeometry(expr, [-5, -5, 5, 5], 0.1);

				//object = THREE.SceneUtils.createMultiMaterialObject( fn, materials);
				object = new THREE.Mesh(fn, wireframe1);

				object.doubleSided = true;

				object.position.set( 0, 0, 0 );
				//objectsBranch.add(object);

				var materials2 = [
					//new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: THREE.ImageUtils.loadTexture( 'textures/ash_uvgrid01.jpg' ) } ),
					new THREE.MeshBasicMaterial( { color: 0x6688ff, wireframe: false, transparent: true, opacity: 0.5 } )

				];


				//object = THREE.SceneUtils.createMultiMaterialObject( new THREE.FunctionSurfaceGeometry(dfdx, [-500, -500, 500, 500]), materials2);
				var fn2 = new CALC.FunctionSurfaceGeometry(dfdx, [-5, -5, 5, 5], 0.1);
				object = new THREE.Mesh(fn2, surface1);
				object.position.set( 0, 0, 0 );
				object.doubleSided = true;

				//objectsBranch.add(object);


				object = new THREE.AxisHelper();
				object.position.set( 0, 0, 0 );
				object.scale.x = object.scale.y = object.scale.z = 0.004;
				objectsBranch.add(object);
				
				
				scene.add(objectsBranch);
				
				var evtHandle = CALC.rotate(objectsBranch, {
					y: Math.PI
				}, {
					duration: 120,
					interpolation: CALC.interpolations.quintic,
					delay: 120
				}, function() {
					CALC.translate(objectsBranch,{
						z: 2
					}, {
						duration: 30,
						interpolation: CALC.interpolations.quintic
					}, function() {
				
						CALC.rotate(objectsBranch,{
							z: Math.PI
						}, {
							duration: 30,
							interpolation: CALC.interpolations.quintic
						});
						
						CALC.translate(objectsBranch,{
							z: 0
						}, {
							duration: 15,
							interpolation: CALC.interpolations.quintic
						});
						
						CALC.fade(surface1,{
							opacity: 0
						}, {
							duration: 50,
							interpolation: CALC.interpolations.quintic
						}, function() {
							CALC.fade(surface1,{
								opacity: 0.5
							}, {
								duration: 15,
								interpolation: CALC.interpolations.quintic
							});
						});
						
						CALC.fade(wireframe1,{
							opacity: 0.4
						}, {
							duration: 50,
							interpolation: CALC.interpolations.quintic
						}, function() {
							CALC.fade(surface1,{
								opacity: 0
							}, {
								duration: 15,
								interpolation: CALC.interpolations.quintic
							});
							CALC.fade(wireframe1,{
								opacity: 0
							}, {
								duration: 15,
								interpolation: CALC.interpolations.quintic
							}, function() {

								CALC.translate(objectsBranch,{
									z: 2
								}, {
									duration: 500,
									interpolation: CALC.interpolations.cubic
								});

								CALC.rotate(objectsBranch,{
									z: Math.PI*8
								}, {
									duration: 500,
									interpolation: CALC.interpolations.cubic
								});
							});
						});
					});
				});
				
				/*setTimeout(function() {
					console.log("stopping!");
					evtHandle.pause();
					setTimeout(function() {
						evtHandle.resume();
					}, 2000);
				}, 4000);
	

				var points = [];

				for ( var i = 0; i < 50; i ++ ) {

					points.push( new THREE.Vector3( Math.sin( i * 0.2 ) * 15 + 50, 0, ( i - 5 ) * 2 ) );

				}

				/*object = new THREE.AxisHelper();
				object.position.set( 200, 0, -200 );
				object.scale.x = object.scale.y = object.scale.z = 0.5;
				scene.add( object );*/

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
				
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {
				var timer = Date.now() * 0.0001;
				
				//calcSpin();
				
				//objectsBranch.rotation.z = lon * (-0.1) + spinZ;
				//objectsBranch.rotation.x = lat * (-0.1) + spinX;
				objectsBranch.rotation.z += (lon - lastLon) * (-0.1);
				objectsBranch.rotation.x += (lat - lastLat) * (-0.1);
				lastLon = lon;
				lastLat = lat;
				
				renderer.render( scene, camera );
			}
			
			function onDocumentMouseDown( event ) {

				event.preventDefault();

				isUserInteracting = true;
				stepZ = 0;
				stepX = 0;

				onPointerDownPointerX = event.clientX;
				onPointerDownPointerY = event.clientY;

				onPointerDownLon = lon;
				onPointerDownLat = lat;

			}

			function onDocumentMouseMove( event ) {
				curX = event.clientX;
				curY = event.clientY;
				if ( isUserInteracting ) {
					//lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
					//lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
					lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
					lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
					render();
				}
			}

			function onDocumentMouseUp( event ) {

				isUserInteracting = false;
				render();
				wasUserInteracting = true;

			}

			function onDocumentMouseWheel( event ) {

				camera.fov -= event.wheelDeltaY * 0.05;
				camera.fov = camera.fov > 170 ? 170 : (camera.fov < 5 ? 5 : camera.fov);
				
				camera.updateProjectionMatrix();

				render();

			}
			
			function calcSpin() {
				var output = "";
				rec %= 10;
				recX[rec] = curX;
				recY[rec] = curY;
				if (wasUserInteracting) {
					var firstRec = (rec + 1) % 10;
					var avX = (recX[rec] - recX[firstRec]) / 10;
					var avY = (recY[rec] - recY[firstRec]) / 10;
					stepZ = (avX > 1 || avX < -1 ? avX*0.01 : 0);
					stepX = (avY > 1 || avY < -1 ? -avY*0.01 : 0);
				}
				spinZ += stepZ;
				spinX += stepX;
				rec++;
				wasUserInteracting = false;
			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					onPointerDownPointerX = event.touches[ 0 ].pageX;
					onPointerDownPointerY = event.touches[ 0 ].pageY;

					onPointerDownLon = lon;
					onPointerDownLat = lat;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					lon = ( onPointerDownPointerX - event.touches[0].pageX ) * 0.1 + onPointerDownLon;
					lat = ( event.touches[0].pageY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;

					render();

				}

			}

		</script>
		<div id="console"></div>


	</body>
</html>
