<!doctype html>
<html lang="en">
	<head>
		<title>three.js webgl - geometries</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
			#console {
				color: #9f8;
			}
		</style>
	</head>
	<body>
		<script type="text/javascript">
		    function pln(a) {
		        console.log(a);
		    }

		</script>
		<script src="../build/Three.js"></script>
		
		<script src="../src/calculus/expressionTree.js"></script>
		<script src="../src/calculus/nodeVisitor.js"></script>
		<script src="../src/calculus/evaluator.js"></script>
		<script src="../src/calculus/simplifier.js"></script>
		<script src="../src/calculus/differentiator.js"></script>
		<script src="../src/calculus/parser.js"></script>
		<script src="../src/calculus/tangent.js"></script>
		<script src="../src/calculus/FunctionGeometry.js"></script>
		<script src="../src/calculus/scheduler.js"></script>


		<script src="js/Detector.js"></script>
		<script src="js/Stats.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, objectsBranch, renderer;
			
			var texture_placeholder,
			isUserInteracting = false,
			wasUserInteracting = false,
			spinZ = 0, spinX = 0, stepZ = 0, stepX = 0, curX = 0, curY = 0,
			recX = [0,0,0,0,0,0,0,0,0,0,0], recY = [0,0,0,0,0,0,0,0,0,0,0], rec = 0,
			onMouseDownMouseX = 0, onMouseDownMouseY = 0,
			lon = 0, onMouseDownLon = 0,
			lat = 0, onMouseDownLat = 0,
			phi = 0, theta = 0,
			target = new THREE.Vector3();
			origin = new THREE.Vector3(0,0,0);

			init();
			//animate();
			CALC.scheduler.animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				scene = new THREE.Scene();

				camera = new THREE.ScreenCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.y = 1000;
				camera.position.z = 200;
				camera.lookAt(origin);
				scene.add(camera);

				var light, object, materials;

				scene.add( new THREE.AmbientLight( 0x404040 ) );

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 1000, 400 );
				scene.add( light );

				/*materials = [
					new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: THREE.ImageUtils.loadTexture( 'textures/ash_uvgrid01.jpg' ) } ),
					new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true, transparent: true, opacity: 0.1 } )
				];*/

				surface1 = new THREE.MeshBasicMaterial( { color: 0xbbbbff, wireframe: false, transparent: true, opacity: 0.5 } );
				
				wireframe1 = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true, transparent: true, opacity: 0.1 } );
				
				materials = [
					//new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: THREE.ImageUtils.loadTexture( 'textures/ash_uvgrid01.jpg' ) } ),
					surface1,
					wireframe1

				];

				
				objectsBranch = new THREE.Branch();
				objectsBranch.position.set( 0, 0, 0 );
				scene.add(objectsBranch);

				var expr = SYM.parse('50*cos(x/150)*sin(y/150)');
				//var expr = SYM.parse('(x/50)^2*(0-y/50)^2');
				var dfdx = expr.tangentialPlane(-120, -280);
				//console.log(dfdx);

				var fn = new THREE.FunctionGeometry(expr, [-500, -500, 500, 500]);

				object = THREE.SceneUtils.createMultiMaterialObject( fn.clip() , materials);
				object.position.set( 0, 0, 0 );
				objectsBranch.add(object);

					var materials2 = [
					//new THREE.MeshLambertMaterial( { ambient: 0xbbbbbb, map: THREE.ImageUtils.loadTexture( 'textures/ash_uvgrid01.jpg' ) } ),
					new THREE.MeshBasicMaterial( { color: 0x6688ff, wireframe: false, transparent: true, opacity: 0.5 } )

				];


				object = THREE.SceneUtils.createMultiMaterialObject( new THREE.FunctionGeometry(dfdx, [-500, -500, 500, 500]), materials2);
				object.position.set( 0, 0, 0 );
				object.rotation.y = Math.PI;
				objectsBranch.add(object);


				object = new THREE.AxisHelper();
				object.position.set( 0, 0, 0 );
				object.scale.x = object.scale.y = object.scale.z = 0.2;
				objectsBranch.add(object);
				
				
				scene.add(objectsBranch);
				
				CALC.rotate(objectsBranch, {
					y: Math.PI
				}, {
					duration: 120,
					interpolation: CALC.interpolations.quintic,
					delay: 120
				}, function() {
					CALC.translate(objectsBranch,{
						z: 200
					}, {
						duration: 30,
						interpolation: CALC.interpolations.quintic
					}, function() {
						CALC.rotate(objectsBranch,{
							z: Math.PI
						}, {
							duration: 30,
							interpolation: CALC.interpolations.quintic
						});
						
						CALC.translate(objectsBranch,{
							z: 0
						}, {
							duration: 15,
							interpolation: CALC.interpolations.quintic
						});
						
						CALC.fade(surface1,{
							opacity: 0
						}, {
							duration: 50,
							interpolation: CALC.interpolations.quintic
						}, function() {
							CALC.fade(surface1,{
								opacity: 0.5
							}, {
								duration: 15,
								interpolation: CALC.interpolations.quintic
							});
						});
						
						CALC.fade(wireframe1,{
							opacity: 0
						}, {
							duration: 50,
							interpolation: CALC.interpolations.quintic
						}, function() {
							CALC.fade(wireframe1,{
								opacity: 0.1
							}, {
								duration: 15,
								interpolation: CALC.interpolations.quintic
							});
						});
					});
				});


				var points = [];

				for ( var i = 0; i < 50; i ++ ) {

					points.push( new THREE.Vector3( Math.sin( i * 0.2 ) * 15 + 50, 0, ( i - 5 ) * 2 ) );

				}

				/*object = new THREE.AxisHelper();
				object.position.set( 200, 0, -200 );
				object.scale.x = object.scale.y = object.scale.z = 0.5;
				scene.add( object );*/

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
				
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {
				var timer = Date.now() * 0.0001;
				
				//calcSpin();
				
				//objectsBranch.rotation.z = lon * (-0.1) + spinZ;
				//objectsBranch.rotation.x = lat * (-0.1) + spinX;
				
				renderer.render( scene, camera );
			}
			
			function onDocumentMouseDown( event ) {

				event.preventDefault();

				isUserInteracting = true;
				stepZ = 0;
				stepX = 0;

				onPointerDownPointerX = event.clientX;
				onPointerDownPointerY = event.clientY;

				onPointerDownLon = lon;
				onPointerDownLat = lat;

			}

			function onDocumentMouseMove( event ) {
				curX = event.clientX;
				curY = event.clientY;
				if ( isUserInteracting ) {
					lon = ( onPointerDownPointerX - event.clientX ) * 0.1 + onPointerDownLon;
					lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;
					render();
				}
			}

			function onDocumentMouseUp( event ) {

				isUserInteracting = false;
				render();
				wasUserInteracting = true;

			}

			function onDocumentMouseWheel( event ) {

				camera.fov -= event.wheelDeltaY * 0.05;
				camera.fov = camera.fov > 170 ? 170 : (camera.fov < 5 ? 5 : camera.fov);
				
				camera.updateProjectionMatrix();

				render();

			}
			
			function calcSpin() {
				var output = "";
				rec %= 10;
				recX[rec] = curX;
				recY[rec] = curY;
				if (wasUserInteracting) {
					var firstRec = (rec + 1) % 10;
					var avX = (recX[rec] - recX[firstRec]) / 10;
					var avY = (recY[rec] - recY[firstRec]) / 10;
					stepZ = (avX > 1 || avX < -1 ? avX*0.01 : 0);
					stepX = (avY > 1 || avY < -1 ? -avY*0.01 : 0);
				}
				spinZ += stepZ;
				spinX += stepX;
				rec++;
				wasUserInteracting = false;
			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					onPointerDownPointerX = event.touches[ 0 ].pageX;
					onPointerDownPointerY = event.touches[ 0 ].pageY;

					onPointerDownLon = lon;
					onPointerDownLat = lat;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					lon = ( onPointerDownPointerX - event.touches[0].pageX ) * 0.1 + onPointerDownLon;
					lat = ( event.touches[0].pageY - onPointerDownPointerY ) * 0.1 + onPointerDownLat;

					render();

				}

			}

		</script>
		<div id="console"></div>


	</body>
</html>
